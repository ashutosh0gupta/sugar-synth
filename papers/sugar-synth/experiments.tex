In this section, we  present our implementation of the proposed method.
%
We also apply our tool on several data sets and illustrate the usability of our method.

{\em Implementation:} 
We have implemented method \textsc{SugarSynth} in a prototype tool {\ourtool}.
%
The tool, written in {\tt C++}, uses {\zthree}\cite{z3} as the SMT solver
to discharge the generated satisfiability queries.
%
% We have developed a specialized file format for giving input to~\ourtool.
% %
% The format allows one to declare monomers, list molecules over the monomers
% in the SMTLIB like format,
% and pass the input parameters of the method.


{\em Benchmark: }
We have applied our tool on three sets of real data (D1,D2,D3,D4) and two sets of synthetic data (D5,D6). The molecules have been obtained from
respiratory mucins of a cystic fibrosis patient (D1),
horse chorionic gonadotropin (D2), SARS-CoV-2 spike protein T323/S325 (D3), and human chorionic gonadotropin from a cancer cell line (D4)~\cite{Jaiman2018,10.1093/glycob/cwaa042}.
The availability of clean data, where we are clear about the source
% and the collection
% methodology used
, limits our choices.

% horse chorionic gonadotropin (D2),
% SARS-COV-2 (D3),
% 
% and
% synthetic data (D5)~\cite{}.

\input{tbl-results}

{\em Results:}
We have applied \ourtool~on the data set. For each data set, we choose several
parameter combinations to illustrate the relative performance of the tool.
If we did not budget large enough parameters such as size of unknown molecules, number of rules etc, then the tool fails to
synthesize the rules.
We present the rules learned after giving minimum resources.
% Our tool gave output that matched with the analysis of~\cite{Jaiman2018}
% in reasonable time.

For D1, we synthesize the rules in 1.60 seconds. Even by reducing the first two parameters, we were able to synthesize the rules but it took longer time.
Giving an extra compartment in the third row did not impact the performance.  We also observe the trade-off between the number of compartments
and the depth of the rules at the second and third row of D1 and how it impacts performance.
We synthesize the rules for D2, involving runaway reactions,  in 7.97 seconds.
For D2, we also learned large rules, i.e., they are adding many nodes at a single time.
We synthesize the rules for D3 in 0.57 seconds. We synthesize the rules for D4, which is also our motivating example, in 0.85 seconds.
However, if we use too many resources or too little, the tool runs for a long time as the search in combinatorial space is highly sensitive to the parameters.
The synthesis for D5 takes 0.72 seconds. We can observe that by reducing the number of rules to learn, the tool fails to learn rules as it required minimum 7 rules. More experiments on the variations - non-monotonic rules and unbounded molecules are included in the \hyperref[sec:appendix]{appendix}.

% The results suggest that the tool is potentially applicable to larger data sets.

% Currently, the tool does not have any objective function to optimize the synthesized rules.
% We are hoping to see more data sets such that we can develop a clearer picture
% for a reasonable objective function.


% ==============================================================================

% Our synthesized production rules for the first three data sets
% match with the reported rules in the literature.
% For the fourth, there is no hypothesis available to us.

% with
% the variants discussed earlier.
% However, we have not fully modeled all the information
% and biological intuition --- for example, the objective function for the rules.

% As we have discussed earlier, we have implemented variants that encode 

%--------------------- DO NOT ERASE BELOW THIS LINE --------------------------

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
